{"version":3,"sources":["meteor://ðŸ’»app/packages/matteodem_easy-search/lib/easy-search-common.js","meteor://ðŸ’»app/packages/matteodem_easy-search/lib/easy-search-convenience.js","meteor://ðŸ’»app/packages/matteodem_easy-search/lib/searchers/mongo.js","meteor://ðŸ’»app/packages/matteodem_easy-search/lib/easy-search-server.js","meteor://ðŸ’»app/packages/matteodem_easy-search/lib/searchers/elastic-search.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wH;;;;;;;;;;;;;;;;;;ACxWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uH;;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wH;;;;;;;;;;;;;;;;;;AC9KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uH;;;;;;;;;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wH","file":"/packages/matteodem_easy-search.js","sourcesContent":["EasySearch = (function () {\n  'use strict';\n\n  var ESCounts,\n    Searchers,\n    indexes = {/** @see defaultOptions */},\n    defaultOptions = {\n      'format' : 'mongo',\n      'skip' : 0,\n      'limit' : 10,\n      'use' : 'minimongo',\n      'reactive' : true,\n      'useTextIndexes' : false,\n      'props' : {},\n      'permission'  : function () {\n        return true;\n      },\n      'transform' : function () {},\n      'sort' : function () {\n        if (Searchers[this.use]) {\n          return Searchers[this.use].defaultSort(this);\n        }\n\n        return {};\n      },\n      'reactiveSort' : function () {\n        if ('minimongo' === this.use || 'mongo-db' === this.use) {\n          return this.sort();\n        }\n\n        return ['_sortedOrder'];\n      },\n      'count' : function () {\n        var doc = ESCounts.findOne({ _id : this.name });\n\n        if (doc) {\n          return doc.count;\n        }\n\n        return 0;\n      },\n      'changeResults' : function (results) {\n        return results;\n      },\n      /**\n       * When using elastic-search it's the query object,\n       * while using with mongo-db it's the selector object.\n       *\n       * @param {String} searchString\n       * @param {Object} options\n       * @return {Object}\n       */\n      'query' : function (searchString, options) {\n        return Searchers[this.use].defaultQuery(this, searchString);\n      }\n    };\n\n  ESCounts = new Mongo.Collection('esCounts');\n\n  /** Helper Functions */\n  function setUpPublication(name, opts) {\n    Meteor.publish(name + '/easySearch', function (conf) {\n      var resultSet,\n        resultArray,\n        findOptions = {},\n        publishScope = this,\n        resultIds = [],\n        publishHandle;\n\n      check(conf, { value: Match.Optional(String), skip: Number, limit: Match.Optional(Number), props: Object });\n\n      if(!(indexes[name].permission())) {\n        throw new Meteor.Error('not-allowed', \"You're not allowed to search this index!\");\n      }\n\n      indexes[name].skip = conf.skip;\n      indexes[name].limit = conf.limit || indexes[name].limit;\n      indexes[name].props = _.extend(indexes[name].props, conf.props);\n      indexes[name].publishScope = this;\n\n      if (!conf.value) {\n        conf.value = '';\n      }\n\n      resultSet = Searchers[opts.use].search(name, conf.value, indexes[name]);\n\n      ESCounts.update({ _id: name }, { $set: { count: resultSet.total } }, { upsert: true });\n\n      if (!resultSet.results.length) return this.ready();\n\n      if (_.isObject(resultSet.results[0])) {\n        resultIds = _.pluck(resultSet.results, '_id');\n      } else if (_.isString(resultSet.results[0])) {\n        resultIds = resultSet.results;\n      }\n\n      // properly observe the collection!\n      if (opts.returnFields) {\n        findOptions.fields = EasySearch._transformToFieldSpecifiers(opts.returnFields);\n      }\n\n      // TODO: this doesn't work properly, that's why resultIds are used for now\n      // see http://stackoverflow.com/questions/3142260/order-of-responses-to-mongodb-in-query\n      resultArray = _.map(resultIds, function (id) {\n        return { _id: id };\n      });\n\n      publishHandle = opts.collection\n        .find({ $or: resultArray }, findOptions)\n        .observe({\n          added: function (doc) {\n            doc._index = name;\n            doc._sortedOrder = resultIds.indexOf(doc._id);\n            publishScope.added('esSearchResults', doc._id, doc);\n          },\n          changed: function (doc) {\n            doc._sortedOrder = resultIds.indexOf(doc._id);\n            publishScope.changed('esSearchResults', doc._id, doc);\n          },\n          removed: function (doc) {\n            publishScope.removed('esSearchResults', doc._id);\n          }\n        }\n      );\n\n      publishScope.onStop(function () {\n        publishHandle.stop();\n      });\n\n      publishScope.ready();\n    });\n\n    Meteor.publish(name + '/easySearchCount', function () {\n      return ESCounts.find({ '_id' : name });\n    });\n  }\n\n  function extendTransformFunction(collection, originalTransform) {\n    return function (doc) {\n      var transformedDoc = collection._transform(doc);\n      return _.isFunction(originalTransform) ? originalTransform(transformedDoc) : transformedDoc;\n    };\n  }\n\n  if (Meteor.isClient) {\n    /**\n     * find method to let users interact with search results.\n     *\n     * @param {Object} selector\n     * @param {Object} options\n     * @returns {MongoCursor}\n     */\n    defaultOptions.find = function (selector, options) {\n      selector = selector || {};\n      selector._index = this.name;\n\n      if (this.collection._transform) {\n        options.transform = extendTransformFunction(this.collection, options.transform);\n      }\n\n      return ESSearchResults.find(selector, options);\n    };\n\n    /**\n     * findOne method to let users interact with search results.\n     *\n     * @param {Object} selector\n     * @param {Object} options\n     * @returns {Document}\n     */\n    defaultOptions.findOne = function (selector, options) {\n      if (_.isObject(selector) || !selector) {\n        selector = selector || {};\n        selector._index = this.name;\n      }\n\n      if (this.collection._transform) {\n        options.transform = extendTransformFunction(this.collection, options.transform);\n      }\n\n      return ESSearchResults.findOne(selector, options);\n    };\n  }\n\n\n  /**\n   * Searchers contains all engines that can be used to search content, until now:\n   *\n   * minimongo (client): Client side collection for reactive search\n   * elastic-search (server): Elastic search server to search with (fast)\n   * mongo-db (server): MongoDB on the server to search (more convenient)\n   *\n   */\n  Searchers = {};\n\n  return {\n    /**\n     * Placeholder config method.\n     *\n     * @param {Object} newConfig\n     */\n    'config' : function (newConfig) {\n      return {};\n    },\n    /**\n     * Simple logging method.\n     *\n     * @param {String} message\n     * @param {String} type\n     */\n    'log' : function (message, type) {\n      type = type || 'log';\n\n      if (console && _.isFunction(console[type])) {\n        return console[type](message);\n      } else if (console && _.isFunction(console.log)) {\n        return console.log(message);\n      }\n    },\n    /**\n     * Create a search index.\n     *\n     * @param {String} name\n     * @param {Object} options\n     */\n    'createSearchIndex' : function (name, options) {\n      check(name, Match.OneOf(String, null));\n      check(options, Object);\n\n      options.name = name;\n      options.field = _.isArray(options.field) ? options.field : [options.field];\n      indexes[name] = _.extend(_.clone(defaultOptions), options);\n\n      options = indexes[name];\n\n      if (Meteor.isServer && EasySearch._usesSubscriptions(name)) {\n        setUpPublication(name, indexes[name]);\n      }\n\n      Searchers[options.use] && Searchers[options.use].createSearchIndex(name, options);\n    },\n    /**\n     * Perform a search.\n     *\n     * @param {String} name             the search index\n     * @param {String} searchString     the string to be searched\n     * @param {Object} options          defined with createSearchIndex\n     * @param {Function} callback       optional callback to be used\n     */\n    'search' : function (name, searchString, options, callback) {\n      var results,\n        index = indexes[name],\n        searcherType = index.use;\n\n      check(name, String);\n      check(searchString, String);\n      check(options, Object);\n      check(callback, Match.Optional(Function));\n\n      if (\"undefined\" === typeof Searchers[searcherType]) {\n        throw new Meteor.Error(500, \"Couldnt search with type: '\" + searcherType + \"'\");\n      }\n\n      if(!(indexes[name].permission())) {\n        throw new Meteor.Error('not-allowed', \"You're not allowed to search this index!\");\n      }\n\n      results = Searchers[searcherType].search(name, searchString, _.extend(indexes[name], options), callback);\n\n      return index.changeResults(results);\n    },\n    /**\n     * Retrieve a specific index configuration.\n     *\n     * @param {String} name\n     * @return {Object}\n     * @api public\n     */\n    'getIndex' : function (name) {\n      return indexes[name];\n    },\n    /**\n     * Retrieve all index configurations\n     */\n    'getIndexes' : function () {\n      return indexes;\n    },\n    /**\n     * Retrieve a specific Seacher.\n     *\n     * @param {String} name\n     * @return {Object}\n     * @api public\n     */\n    'getSearcher' : function (name) {\n      return Searchers[name];\n    },\n    /**\n     * Retrieve all Searchers.\n     */\n    'getSearchers' : function () {\n      return Searchers;\n    },\n    /**\n     * Loop through the indexes and provide the configuration.\n     *\n     * @param {Array|String} indexes\n     * @param callback\n     */\n    'eachIndex' : function (indexes, callback) {\n      indexes = !_.isArray(indexes) ? [indexes] : indexes;\n\n      _.each(indexes, function (index) {\n        callback(index, EasySearch.getIndex(index));\n      });\n    },\n    /**\n     * Makes it possible to override or extend the different\n     * types of search to use with EasySearch (the \"use\" property)\n     * when using EasySearch.createSearchIndex()\n     *\n     * @param {String} key      Type, e.g. mongo-db, elastic-search\n     * @param {Object} methods  Methods to be used, only 2 are required:\n     *                          - createSearchIndex (name, options)\n     *                          - search (name, searchString, [options, callback])\n     *                          - defaultQuery (options, searchString)\n     *                          - defaultSort (options)\n     */\n    'createSearcher' : function (key, methods) {\n      check(key, String);\n      check(methods.search, Function);\n      check(methods.createSearchIndex, Function);\n\n      Searchers[key] = methods;\n    },\n    /**\n     * Helper to check if searcher uses server side subscriptions for searching.\n     *\n     * @param {String} index Index name to check configuration for\n     */\n    '_usesSubscriptions' : function (index) {\n      var conf = EasySearch.getIndex(index);\n      return conf && conf.reactive && conf.use !== 'minimongo';\n    },\n    /**\n     * Helper to transform an array of fields to Meteor \"Field Specifiers\"\n     *\n     * @param {Array} fields Array of fields\n     */\n    '_transformToFieldSpecifiers' : function (fields) {\n      var specifiers = {};\n\n      _.each(fields, function (field) {\n        specifiers[field] = 1;\n      });\n\n      return specifiers;\n    }\n  };\n})();\n","Meteor.Collection.prototype.initEasySearch = function (fields, options) {\n  if (!_.isObject(options)) {\n    options = {};\n  }\n\n  EasySearch.createSearchIndex(this._name, _.extend(options, {\n    'collection' : this,\n    'field' : fields\n  }));\n};\n\nif (Meteor.isClient) {\n  jQuery.fn.esAutosuggestData = function () {\n    var input = $(this);\n\n    if (input.prop(\"tagName\").toUpperCase() !== 'INPUT') {\n      return [];\n    }\n\n    return EasySearch.getComponentInstance({'id': input.parent().data('id'), 'index': input.parent().data('index')}).get('autosuggestSelected');\n  }\n}\n","var methods = {\n  /**\n   * Set up a search index.\n   *\n   * @param name\n   * @param options\n   * @returns {void}\n   */\n  'createSearchIndex' : function (name, options) {\n    if (Meteor.isServer && options.useTextIndexes) {\n      var indexDoc = EasySearch._transformFieldsToIndexDocument(options.field),\n        rawCollection = EasySearch.getIndex(name).collection.rawCollection(),\n        indexOptions = { name: name };\n\n      if (options.weights) {\n        indexOptions.weights = options.weights();\n      }\n\n      rawCollection.createIndex(\n        indexDoc, indexOptions, function (err, res) {\n          options.onCreatedIndex && options.onCreatedIndex(res);\n        }\n      );\n    }\n  },\n  /**\n   *\n   * Perform a really simple search with mongo db.\n   *\n   * @param {String} name\n   * @param {String} searchString\n   * @param {Object} options\n   * @param {Function} callback\n   * @returns {Object}\n   */\n  'search' : function (name, searchString, options, callback) {\n    var cursor,\n      results,\n      selector,\n      pipeline,\n      aggregates,\n      cursorOptions,\n      index = EasySearch.getIndex(name);\n\n    if (!_.isObject(index)) {\n      return;\n    }\n\n    options.limit = options.limit || 10;\n\n    // if several, fields do an $or search, otherwise only over the field\n    selector = index.query(searchString, options);\n\n    if (!selector) {\n      return { total: 0, results: [] };\n    }\n\n    cursorOptions = {\n      sort : index.sort(searchString, options)\n    };\n\n    if (options.returnFields) {\n      cursorOptions.fields = EasySearch._transformToFieldSpecifiers(options.returnFields);\n    }\n\n    if (options.skip) {\n      cursorOptions.skip = options.skip;\n    }\n\n    if (Meteor.isServer) {\n      cursorOptions.limit = options.limit;\n    }\n\n    if (options.useTextIndexes) {\n      if (!cursorOptions.fields) {\n        cursorOptions.fields = {};\n      }\n\n      cursorOptions.fields.score = { $meta: 'textScore'  };\n    }\n\n    cursor = index.collection.find(selector, cursorOptions);\n\n    if (Meteor.isServer) {\n      // Get the total count by aggregating\n      pipeline = [\n        { $match: selector },\n        {\n          $group: { _id: \"id\", total: { $sum: 1 } }\n        }\n      ];\n\n      aggregates = index.collection.aggregate(pipeline);\n\n      results = {\n        'results': cursor.fetch(),\n        'total': aggregates.length >= 1 ? aggregates[0].total : 0\n      };\n    } else {\n      // The aggregate operations are not supported on client,\n      // so we have to explicitly count all records in the search result\n\n\n      results = {\n        'results' : _.first(cursor.fetch(), options.limit),\n        'total' : cursor.count()\n      };\n    }\n\n    if (_.isFunction(callback)) {\n      callback(results);\n    }\n\n    return results;\n  },\n  /**\n   * The default mongo-db query - selector used for searching.\n   *\n   * @param {Object} conf\n   * @param {String} searchString\n   * @param {Function} regexCallback\n   *\n   * @returns {Object}\n   */\n  'defaultQuery' : function (conf, searchString, regexCallback) {\n    if (Meteor.isServer && conf.useTextIndexes) {\n      return { $text: { $search: searchString } };\n    } else if (Meteor.isClient || !conf.useTextIndexes) {\n      // Convert numbers if configured\n      if (conf.convertNumbers && parseInt(searchString, 10) == searchString) {\n        searchString = parseInt(searchString, 10);\n      }\n\n      var stringSelector = { '$regex' : '.*' + searchString + '.*', '$options' : 'i'},\n        selector = {\n          $or: []\n        };\n\n      if (regexCallback) {\n        stringSelector['$regex'] = regexCallback(searchString);\n      }\n\n      _.each(conf.field, function (fieldString) {\n        var orSelector = {};\n\n        if (_.isString(searchString)) {\n          orSelector[fieldString] = stringSelector;\n        } else if (_.isNumber(searchString)) {\n          orSelector[fieldString] = searchString;\n        }\n\n        selector['$or'].push(orSelector);\n      });\n\n      return selector;\n    }\n  },\n  /**\n   * The default mongo-db sorting method used for sorting the results.\n   *\n   * @param {Object} conf\n   * @return array\n   */\n  'defaultSort' : function (conf) {\n    return conf.field;\n  }\n};\n\nif (Meteor.isClient) {\n  EasySearch.createSearcher('minimongo', methods);\n} else if (Meteor.isServer) {\n  EasySearch.createSearcher('mongo-db', methods);\n}\n\n","'use strict';\nvar ElasticSearch = Npm.require('elasticsearch');\n\nEasySearch._esDefaultConfig = {\n  host : 'localhost:9200'\n};\n\n/**\n * Override the config for Elastic Search.\n *\n * @param {object} newConfig\n */\nEasySearch.config = function (newConfig) {\n  if (\"undefined\" !== typeof newConfig) {\n    check(newConfig, Object);\n    this._config = _.extend(this._esDefaultConfig, newConfig);\n    this.ElasticSearchClient = new ElasticSearch.Client(this._config);\n  }\n\n  return this._config;\n};\n\n/**\n * Get the ElasticSearchClient\n * @see http://www.elasticsearch.org/guide/en/elasticsearch/client/javascript-api/current\n *\n * @return {ElasticSearch.Client}\n */\nEasySearch.getElasticSearchClient = function () {\n  return this.ElasticSearchClient;\n};\n\n/**\n * Transforms the field definition to a MongoDB index doc definition.\n *  \n * @param {Array} fields\n *\n * @returns {Object}\n */\nEasySearch._transformFieldsToIndexDocument = function (fields) {\n  var indexDoc = {};\n\n  _.each(fields, function (field) {\n    indexDoc[field] = 'text';\n  });\n\n  return indexDoc;\n};\n\nMeteor.methods({\n  /**\n   * Make server side search possible on the client.\n   *\n   * @param {String} name\n   * @param {String} searchString\n   * @param {Object} options\n   */\n  easySearch: function (name, searchString, options) {\n    check(name, String);\n    check(searchString, String);\n    check(options, Object);\n    return EasySearch.search(name, searchString, options);\n  }\n});\n","'use strict';\n\nvar Future = Npm.require('fibers/future'),\n  ElasticSearch = Npm.require('elasticsearch');\n\n/**\n * Return Elastic Search indexable data.\n *\n * @param {Object} doc the document to get the values from\n * @return {Object}\n */\nfunction getESFields(doc) {\n  var newDoc = {};\n\n  _.each(doc, function (value, key) {\n    newDoc[key] = _.isObject(value) && !_.isArray(value) && !_.isDate(value) ? JSON.stringify(value) : value;\n  });\n\n  return newDoc;\n}\n\nEasySearch.createSearcher('elastic-search', {\n  /**\n   * Write a document to a specified index.\n   *\n   * @param {String} name\n   * @param {Object} doc\n   * @param {String} id\n   * @param {Object} opts\n   * @param {Object} config\n   */\n  'writeToIndex' : function (name, doc, id, opts, config) {\n    var debugMode = config.debug,\n        transformedDoc = opts.transform(doc);\n\n    if (_.isObject(transformedDoc)) {\n      doc = transformedDoc;\n    }\n\n    // add to index\n    EasySearch.ElasticSearchClient.index({\n      index : name.toLowerCase(),\n      type : 'default',\n      id : id,\n      body : doc\n    }, function (err, data) {\n      if (err) {\n        console.log('Had error adding a document!');\n        console.log(err);\n      }\n\n      if (debugMode && console) {\n        console.log('EasySearch: Added / Replaced document to Elastic Search:');\n        console.log('EasySearch: ' + data + \"\\n\");\n      }\n    });\n  },\n  /**\n   * Setup some observers on the mongo db collection provided.\n   *\n   * @param {String} name\n   * @param {Object} options\n   */\n  'createSearchIndex' : function (name, options) {\n    var searcherScope = this,\n      config = EasySearch.config() || {};\n\n    if (\"undefined\" === typeof EasySearch.ElasticSearchClient) {\n      EasySearch.ElasticSearchClient = new ElasticSearch.Client(this._esDefaultConfig);\n    }\n\n    name = name.toLowerCase();\n\n    options.collection.find().observeChanges({\n      added: function (id, fields) {\n        searcherScope.writeToIndex(name, getESFields(fields), id, options, config);\n      },\n      changed: function (id) {\n        // Overwrites the current document with the new doc\n        searcherScope.writeToIndex(name, getESFields(options.collection.findOne(id)), id, options, config);\n      },\n      removed: function (id) {\n        EasySearch.ElasticSearchClient.delete({\n          index: name,\n          type: 'default',\n          id: id\n        }, function (error, response) {\n          if (config.debug) {\n            console.log('Removed document with id ( ' +  id + ' )!');\n          }\n        });\n      }\n    });\n  },\n  /**\n   * Get the data out of the JSON elastic search response.\n   *\n   * @param {Object} data\n   * @returns {Array}\n   */\n  'extractJSONData' : function (data) {\n    data = _.isString(data) ? JSON.parse(data) : data;\n\n    var results = _.map(data.hits.hits, function (resultSet) {\n      var field = '_source';\n\n      if (resultSet['fields']) {\n        field = 'fields';\n      }\n\n      resultSet[field]['_id'] = resultSet['_id'];\n      return resultSet[field];\n    });\n\n    return {\n      'results' : results,\n      'total' : data.hits.total\n    };\n  },\n  /**\n   * Perform a search with Elastic Search, using fibers.\n   *\n   * @param {String} name\n   * @param {String} searchString\n   * @param {Object} options\n   * @param {Function} callback\n   * @returns {*}\n   */\n  'search' : function (name, searchString, options, callback) {\n    var bodyObj,\n      that = this,\n      fut = new Future(),\n      index = EasySearch.getIndex(name);\n\n    if (!_.isObject(index)) {\n      return;\n    }\n\n    bodyObj = {\n      \"query\" : index.query(searchString, options)\n    };\n\n    if (!bodyObj.query) {\n      return { total: 0, results: [] };\n    }\n\n    bodyObj.sort = index.sort(searchString, options);\n\n    if (options.returnFields) {\n      if (options.returnFields.indexOf('_id') === -1 ) {\n        options.returnFields.push('_id');\n      }\n\n      bodyObj.fields = options.returnFields;\n    }\n\n    // Modify Elastic Search body if wished\n    if (index.body && _.isFunction(index.body)) {\n      bodyObj = index.body(bodyObj, options);\n    }\n\n    name = name.toLowerCase();\n\n    if (\"function\" === typeof callback) {\n      EasySearch.ElasticSearchClient.search(name, bodyObj, callback);\n      return;\n    }\n\n    // Most likely client call, return data set\n    EasySearch.ElasticSearchClient.search({\n      index : name,\n      body : bodyObj,\n      size : options.limit,\n      from: options.skip\n    }, function (error, data) {\n      if (error) {\n        console.log('Had an error while searching!');\n        console.log(error);\n        return;\n      }\n\n      if (\"raw\" !== index.format) {\n        data = that.extractJSONData(data);\n      }\n\n      fut['return'](data);\n    });\n\n    return fut.wait();\n  },\n  /**\n   * The default ES query object used for searching the results.\n   *\n   * @param {Object} options\n   * @param {String} searchString\n   * @return array\n   */\n  'defaultQuery' : function (options, searchString) {\n    return {\n      \"fuzzy_like_this\" : {\n        \"fields\" : options.field,\n        \"like_text\" : searchString\n      }\n    };\n  },\n  /**\n   * The default ES sorting method used for sorting the results.\n   *\n   * @param {Object} options\n   * @return array\n   */\n  'defaultSort' : function (options) {\n    return options.field;\n  }\n});\n\n// Expose ElasticSearch API\nEasySearch.ElasticSearch = ElasticSearch;\n"]}